#!/usr/bin/env python
#script to view fits files generated by wsclean

import glob
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse
from matplotlib.animation import FuncAnimation
from astropy.io import fits
import cv2
import os
import numpy as np
import sunpy.sun
import sunpy.coordinates
from sunpy.coordinates import frames
from astropy.coordinates import SkyCoord, Angle, get_sun
from astropy.table import Table, Column
import astropy.time
import sys
from matplotlib import dates
from astropy.visualization import astropy_mpl_style
from astropy import units as u
import pdb
import scipy.optimize as opt
from multiprocessing import Pool
import argparse
#assume all images are made with sam escale size etc

parser = argparse.ArgumentParser()
parser.add_argument('-indir', dest='indir', help='input directory', default='./')
parser.add_argument('-start', type=int, dest='start', help='Which file to start at (def=0)', default=0)
parser.add_argument('-end', type=int, dest='end', help='Whcih file to end at (def=-1)', default=-1)
parser.add_argument('-xpix', type=int, dest='xpix', help='How many pixels in x (def=1024)', default=1024)
parser.add_argument('-ypix', type=int, dest='ypix', help='How many pixels in y (def=1024)', default=1024)
args = parser.parse_args()
indir = args.indir

"""class plot_burst:
    """
    class to define grid for correct coordinates
    and plot interferometric image
    t = image index
    """
    def __init__(self,t):
        self.t = t"""

def get_grid():
    #set up pixel2coords where the cnetre pixel is the sun centre at 12:00:00 
    #during observation
    no_pix_x, no_pix_y = args.xpix, args.ypix
    with fits.open(files[0]) as hdu:
        obs_ra = hdu[0].header['CRVAL1']
        obs_dec = hdu[0].header['CRVAL2']
        obs_time = hdu[0].header['DATE-OBS']
        str_start = fits.Header.tostring(hdu[0].header).find('scale')
        str_end = fits.Header.tostring(hdu[0].header).find('asec')
        scale = float(fits.Header.tostring(hdu[0].header)[str_start+6:str_end])*u.arcsec
        ra_centre = int(hdu[0].header['CRPIX1']) 
        dec_centre = int(hdu[0].header['CRPIX2'])
    
    #obs_centre = obs_time[:11]+'12:00:00.0'
    obs_ra = Angle(obs_ra, unit='deg').wrap_at('360d')
    obs_dec = Angle(obs_dec, unit='deg')
    #RA, DEC = sunpy.sun.position(t=sunpy.time.parse_time(obs_centre))
    DIST = sunpy.coordinates.get_sunearth_distance(sunpy.time.parse_time(obs_centre))
    grid_eq = SkyCoord(obs_ra, obs_dec, DIST, obstime=obs_centre)
    grid_helio = grid_eq.transform_to(frames.Helioprojective)
    return grid_eq

#def pix2coord(pix_list):
#    #centre at [0,0] == get_grid().ra, get_grid().dec
#    #x = -512...0...512 etc
#    #x,y = x-512, y-512
#    #grid = get_grid()
#    #pix_ra = grid.ra/512
#    #pix_dec = grid.dec/512
#    #ra, dec = grid.ra + x*pix_ra, grid.dec + y*pix_dec
#    
#    
#
#
#    return ra, dec

def find_sun(t):
    #find centre of sun at time t in some coordinate system
    with fits.open(files[t]) as hdu:
        obs_time = hdu[0].header['DATE-OBS']
    RA, DEC = sunpy.sun.position(t=sunpy.time.parse_time(obs_time))
    DIST = sunpy.coordinates.get_sunearth_distance(sunpy.time.parse_time(obs_time)) 
    sun_eq = SkyCoord(RA, DEC, DIST, obstime=obs_time)
    sun_helio = sun_eq.transform_to(frames.Helioprojective)
    return sun_helio

#for i in range(len(im_list)):
def plot_sun(i):
    with fits.open(files[i]) as hdu:
        data = hdu[0].data[0,0]#np.flip(hdu[0].data[0,0], axis=0)
        obs_time = hdu[0].header['DATE-OBS']
        sun_pos = get_sun(astropy.time.Time(obs_time))#sunpy.sun.position(t=sunpy.time.parse_time(obs_time)) 
        BMAJ = hdu[0].header['BMAJ']
        BMIN = hdu[0].header['BMIN']
        BPA = hdu[0].header['BPA']
        MHz = hdu[0].header['CRVAL3']*1e-6
    fig,ax = plt.subplots(1,1,figsize=(6,6))
    #ax.imshow(data, origin="lower", aspect="auto", animated=True, extent=[ra_scale[0].hour, ra_scale[-1].hour, dec_scale[0].deg, dec_scale[-1].deg])
    ax.imshow(data, origin="lower", aspect="auto", animated=True, extent=[ra_scale[0].deg, ra_scale[-1].deg, dec_scale[0].deg, dec_scale[-1].deg])
    sun_x, sun_y = coord2pix(sun_pos.ra, sun_pos.dec)
    #ax.scatter(get_grid().ra.hour, get_grid().dec.deg, c='r', marker='+')
    ax.scatter(sun_pos.ra.deg, sun_pos.dec.deg, c='r', marker='+')
    sun_max = np.where(data==np.max(data))
    ax.scatter(ra_scale[sun_max[1][0]].deg, dec_scale[sun_max[0][0]].deg, c='r', marker='+') #these are reversed to what you would think
    sun_rad = Angle(0.5*u.deg)
    p = Ellipse((sun_pos.ra.deg, sun_pos.dec.deg),sun_rad.deg,sun_rad.deg, fill=False, color='r')
    #p = Ellipse((get_grid().ra.hour, get_grid().dec.deg),sun_rad.hour,sun_rad.deg, fill=False, color='r')
    b = Ellipse((pix2coord(100,100)[0]*15, pix2coord(100,100)[1]),BMIN,BMAJ,angle=BPA+45, fill=False, color='w') 
#    b1 = Ellipse((pix2coord(100,100)[0]*15, pix2coord(100,100)[1]),BMAJ,BMIN,angle=270+BPA+23.5, fill=False, color='r') 
   # ax = plt.gca()
   # x, y = np.meshgrid(ra_scale.hour, dec_scale.deg)
   # guess = (np.max(im_list[i])/2,13.4, -9, 0.2, 0.2, 0, 0)
   # popt, pcov = opt.curve_fit(fit_2d_gauss, (x,y), im_list[i].ravel(), p0=guess)
    ax.add_patch(p)
    ax.add_patch(b)
 #   ax.add_patch(b1)
    plt.xlabel('RA (deg)')
    plt.ylabel('Declination (deg)')
    plt.title("Sun at "+"{:.2f}".format(MHz)+ " MHz "+obs_time)
    plt.savefig(indir + str(i).zfill(4) +'.png')
    #plt.close()
#plt.show()
def burst_dist(i):
    sun_x, sun_y = coord2pix(sun_pos[i][0], sun_pos[i][1])
    sun_max = np.where(im_list[i]==np.max(im_list[i]))
def coord2pix(ra, dec):
    dra = ra_scale[1]-ra_scale[0]
    ddec = dec_scale[1]-dec_scale[0]
    x = np.round((1./dra.hour)*(ra.hour-ra_scale[0].hour))
    y = np.round((1./ddec.deg)*(dec.deg-dec_scale[0].deg))
    x = int(x)
    y = int(y)
    return x, y
def pix2coord(x, y):
    ra = ra_scale[x].hour
    dec = dec_scale[y].deg
    return ra, dec
def fit_2d_gauss(xy, amp, x0, y0, sig_x, sig_y, theta, offset):
    #pdb.set_trace()
    (x, y) = xy
    x0 = float(x0)
    y0 = float(y0)
    a = ((np.cos(theta)**2)/(2*sig_x**2)) + ((np.sin(theta)**2)/(2*sig_y**2))
    b = -((np.sin(2*theta))/(4*sig_x**2)) + ((np.sin(2*theta))/(4*sig_y**2))
    c = ((np.sin(theta)**2)/(2*sig_x**2)) + ((np.cos(theta)**2)/(2*sig_y**2))
    g = amp*np.exp(-(a*((x-x0)**2) + 2*b*(x-x0)*(y-y0) + c*((y-y0)**2))) + offset
    #pdb.set_trace()
    return g.ravel()


start_f=args.start
end_f = args.end
#pdb.set_trace()
files = glob.glob(indir+"*.fits")
files.sort()
#pdb.set_trace()
if end_f == -1:
    end_f = len(files)
#im_list = []
#time_list = []
#for f in range(start_f, end_f):
#    with fits.open(files[f]) as hdu:
#        print(f)
#        data = np.flip(hdu[0].data[0,0], axis=0)
#        time_list.append(hdu[0].header['DATE-OBS'])
#        im_list.append(data)

#sun_pos = [sunpy.sun.position(t=sunpy.time.parse_time(time_list[i])) for i in range(len(time_list))] 
#sun_pos_lon = [sunpy.sun.position(t=sunpy.time.parse_time(time_list[i]))[0].deg for i in range(len(time_list))] 
#sun_pos_lat = [sunpy.sun.position(t=sunpy.time.parse_time(time_list[i]))[1].deg for i in range(len(time_list))] 


#no_pix_x, no_pix_y = args.xpix, args.ypix
#with fits.open(files[0]) as hdu:
#    str_start = fits.Header.tostring(hdu[0].header).find('scale')
#    str_end = fits.Header.tostring(hdu[0].header).find('asec')
#    scale = float(fits.Header.tostring(hdu[0].header)[str_start+6:str_end])*u.arcsec
#    ra_centre = int(hdu[0].header['CRPIX1']) 
#    dec_centre = int(hdu[0].header['CRPIX2'])
#fov = no_pix_x * scale 
#ra_fov = fov.to(u.hourangle)
#dec_fov = fov.to(u.deg)
#
#
#dec_scale = Angle(np.zeros(no_pix_y), unit='deg')
#dec_scale[513] = get_grid().dec
#dec_scale = [dec_scale[513] + (i-513)*scale for i in range(no_pix_y)]
#
#ra_scale = Angle(np.zeros(no_pix_x), unit='hourangle')
#ra_scale[513] = get_grid().ra
#ra_scale = [ra_scale[513] + (i-513)*scale for i in range(no_pix_x)]
##ra_scale = np.linspace((get_grid().ra.to(u.hourangle)-ra_fov/2), (get_grid().ra.to(u.hourangle)+ra_fov/2), 1024)
##dec_scale = np.linspace((get_grid().dec-dec_fov/2), (get_grid().dec+dec_fov/2), 1024)
##ra_scale = np.linspace(-ra_fov/2, ra_fov/2, 1025)
##ra_scale = ra_scale + get_grid().ra
##ra_scale = ra_scale[:-1]
##dec_scale = np.linspace(-dec_fov/2, dec_fov/2, 1025)
##dec_scale = dec_scale + get_grid().dec
##dec_scale = dec_scale[:-1]
#
#
#arcmin_scale =  np.linspace(0, fov.to(u.arcmin), 1024)
#arcmin_scale = arcmin_scale -fov/2
##ra_scale = arcmin_scale + get_grid().ra
#dec_scale = arcmin_scale + get_grid().dec
#with Pool() as p:
#    p.map(plot_sun, range(start_f, end_f))


#pdb.set_trace()
#images = glob.glob(indir+'*.png')
#images.sort()
#output = indir+'sun.mp4'
#image_path = images[0]
#frame = cv2.imread(image_path)
#cv2.imshow('video', frame)
#height, width, channels = frame.shape
#
#fourcc = cv2.VideoWriter_fourcc(*'mp4v')
#out = cv2.VideoWriter(output, fourcc, 20., (width, height))
#
#for image in images:
#    image_paTH = image
#    frame = cv2.imread(image_path)
#    out.write(frame)
#    cv2.imshow('video', frame)
#    if (cv2.waitKey(1) & 0xFF) == ord('q'):
#        break
#
#out.release()
#cv2.destroyAllWindows()


#ax.set_title("Sun")
#ax.set_xlabel("X (pixels)")
#ax.set_ylabel("Y (pixels)")
#t_data, I_data = [], []
#ln, = plt.plot([],[],animated='True')
#ln1, = plt.plot([],[],animated='True')
#title = ax.text(0.85, 0.9, "", bbox={'facecolor':'w', 'pad':5}, transform=ax.transAxes,  ha='center')
#def init():
#    ax.set_xlim(t_arr[0], t_arr[-1])
#    ax.set_ylim(-0.5, 2.5)
#    return ln,
##arr1 = [None]
#def update(subband):
#    t_data = t_arr
#    I_data = spike_sub[:,subband]
#    fit_data = fits[subband-sbs_start]
#    title.set_text(u"Subband: {}".format(subband))
#    #ax.set_title("Subband:" + str(subband))
#    #if arr1[0]: arr1.remove(arr1[0])
#    #arr1[0] = ax.plot(t_data, I_data)
#    ln.set_data(t_data, I_data)
#    ln1.set_data(t_data,fit_data)
#    return ln, ln1, title,
#
#ani = FuncAnimation(fig, update, frames=range(sbs_start,sbs), init_func=init, interval=10, blit=True)
#ani.save("burst_fits.mp4")
#fig = plt.figure()
#
#
#def im_data(j):
#    return im_list[j]
#
#i = 0
#im = plt.imshow(im_data(i), aspect="auto", cmap="viridis", animated=True, extent=[arcmin_scale[0].value, arcmin_scale[-1].value, arcmin_scale[-1].value, arcmin_scale[0].value])
#
#def updatefig(*args):
#    global i
#    if i < len(im_list):
#        im.set_array(im_data(i))
#    i +=1
#    return im,
#plt.xlabel('X (arcmin)')
#plt.ylabel('Y (arcmin)')
#ani = FuncAnimation(fig, updatefig, interval=1, blit=True)
#plt.show()
#
