#!/usr/bin/env python
#script to view fits files generated by wsclean

import glob
import h5py
import matplotlib.pyplot as plt
from matplotlib import dates
from matplotlib.patches import Circle, Ellipse
from matplotlib.animation import FuncAnimation
from datetime import datetime, timedelta
from astropy.io import fits
import cv2
import os
import numpy as np
import sunpy.sun
import sunpy.coordinates
from sunpy.coordinates import frames
from astropy.coordinates import SkyCoord, Angle, get_sun
from astropy.table import Table, Column
import astropy.time
import sys
from matplotlib import dates
from astropy.visualization import astropy_mpl_style
from astropy import units as u
import pdb
import scipy.optimize as opt
from multiprocessing import Pool
import argparse
#assume all images are made with sam escale size etc

parser = argparse.ArgumentParser()
parser.add_argument('-indir', dest='indir', help='input directory', default='./')
parser.add_argument('-bf', dest='bf', help='beamformed file', default='/net/romulus.ap.dias.ie/romulus/murphp30_data/typeIII_int/L401005_SAP000_B000_S0_P000_bf.h5')
parser.add_argument('-start', type=int, dest='start', help='Which file to start at (def=0)', default=0)
parser.add_argument('-end', type=int, dest='end', help='Whcih file to end at (def=-1)', default=-1)
parser.add_argument('-xpix', type=int, dest='xpix', help='How many pixels in x (def=1024)', default=1024)
parser.add_argument('-ypix', type=int, dest='ypix', help='How many pixels in y (def=1024)', default=1024)
args = parser.parse_args()
indir = args.indir
bf_file = args.bf

no_pix_x, no_pix_y = args.xpix, args.ypix
start_f=args.start
end_f = args.end
#pdb.set_trace()
f_list = glob.glob(indir+"*.fits")
f_list.sort()
#pdb.set_trace()
if end_f == -1:
	end_f = len(f_list)

#dec_scale = Angle(np.zeros(no_pix_y), unit='deg')
#dec_scale[513] = get_grid().dec
#dec_scale = [dec_scale[513] + (i-513)*scale for i in range(no_pix_y)]
#
#ra_scale = Angle(np.zeros(no_pix_x), unit='hourangle')
#ra_scale[513] = get_grid().ra
#ra_scale = [ra_scale[513] + (i-513)*scale for i in range(no_pix_x)]

class plot_burst:
	"""
	class to define grid for correct coordinates
	and plot interferometric image
	files = list of fits files
	xpix, ypix = no of x,y pixels
	t = image index
	"""
	def __init__(self,t,files=f_list,xpix=no_pix_x,ypix=no_pix_y):
		self.files = files
		self.xpix, self.ypix = xpix, ypix
		self.t = t

		with fits.open(self.files[self.t]) as hdu:
			str_start = fits.Header.tostring(hdu[0].header).find('scale')
			str_end = fits.Header.tostring(hdu[0].header).find('asec')
			self.scale = Angle(float(fits.Header.tostring(hdu[0].header)[str_start+6:str_end])*u.arcsec)
	
			self.data = hdu[0].data[0,0]
			self.obs_time = hdu[0].header['DATE-OBS']
			self.sun_pos = get_sun(astropy.time.Time(self.obs_time))#sunpy.sun.position(t=sunpy.time.parse_time(obs_time)) 
			self.BMAJ = hdu[0].header['BMAJ']
			self.BMIN = hdu[0].header['BMIN']
			self.BPA = hdu[0].header['BPA']
			self.MHz = hdu[0].header['CRVAL3']*1e-6
			self.ra_centre = int(hdu[0].header['CRPIX1']) 
			self.dec_centre = int(hdu[0].header['CRPIX2'])
	
			self.obs_ra = hdu[0].header['CRVAL1']
			self.obs_dec = hdu[0].header['CRVAL2']
	
	def get_grid(self):
	   
		#obs_centre = obs_time[:11]+'12:00:00.0'
		obs_ra = Angle(self.obs_ra, unit='deg').wrap_at('360d')
		obs_dec = Angle(self.obs_dec, unit='deg')
		#RA, DEC = sunpy.sun.position(t=sunpy.time.parse_time(obs_centre))
		DIST = sunpy.coordinates.get_sunearth_distance(sunpy.time.parse_time(self.obs_time))
		grid_eq = SkyCoord(obs_ra, obs_dec, DIST, obstime=self.obs_time)
		grid_helio = grid_eq.transform_to(frames.Helioprojective)
		return grid_eq
	
	def find_sun(self):
		#find centre of sun at time t in some coordinate system
		RA, DEC = sunpy.sun.position(t=sunpy.time.parse_time(self.obs_time))
		DIST = sunpy.coordinates.get_sunearth_distance(sunpy.time.parse_time(self.obs_time)) 
		sun_eq = SkyCoord(RA, DEC, DIST, obstime=self.obs_time)
		sun_helio = sun_eq.transform_to(frames.Helioprojective)
		return sun_helio
	
	def plot_sun_pix(self):
	#plot image with sun overlaid, also include beam	
		fig,(ax,ax1) = plt.subplots(2,1,figsize=(7,7), gridspec_kw={'height_ratios':[3,1]})
		#ax.imshow(data, origin="lower", aspect="auto", animated=True, extent=[ra_scale[0].hour, ra_scale[-1].hour, dec_scale[0].deg, dec_scale[-1].deg])
		#ax.imshow(data, origin="lower", aspect="auto", animated=True, extent=[ra_scale[0].deg, ra_scale[-1].deg, dec_scale[0].deg, dec_scale[-1].deg])
		ax.imshow(self.data, origin="lower", aspect="equal",vmax=np.percentile(self.data, 99.9), vmin=np.percentile(self.data, 0.1))
		sun_x, sun_y = self.ra_centre, self.dec_centre#coord2pix(sun_pos.ra, sun_pos.dec)
		#ax.scatter(get_grid().ra.hour, get_grid().dec.deg, c='r', marker='+')
		#ax.scatter(sun_pos.ra.deg, sun_pos.dec.deg, c='r', marker='+')
		ax.scatter(sun_x, sun_y, c='r', marker='+')
		#sun_max = np.where(data==np.max(data))
		#ax.scatter(ra_scale[sun_max[1][0]].deg, dec_scale[sun_max[0][0]].deg, c='r', marker='+') #these are reversed to what you would think
		sun_rad = Angle(0.25*u.deg)
		sun_rad_pix = sun_rad.deg/self.scale.deg
		#p = Ellipse((sun_pos.ra.deg, sun_pos.dec.deg),sun_rad.deg,sun_rad.deg, fill=False, color='r')
		p = Circle((sun_x, sun_y),sun_rad_pix, fill=False, color='r')
		#p = Ellipse((get_grid().ra.hour, get_grid().dec.deg),sun_rad.hour,sun_rad.deg, fill=False, color='r')
		#b = Ellipse((pix2coord(100,100)[0]*15, pix2coord(100,100)[1]),BMIN,BMAJ,angle=BPA+45, fill=False, color='w') 
		b = Ellipse((100,100),self.BMAJ/self.scale.deg,self.BMIN/self.scale.deg,angle=90-self.BPA+23.5, fill=False, color='w') 
		#b1 = Ellipse((513,513),BMAJ/self.scale.deg,BMIN/self.scale.deg,angle=90-BPA+23.5, fill=False, color='b') 
	#	 b1 = Ellipse((pix2coord(100,100)[0]*15, pix2coord(100,100)[1]),BMAJ,BMIN,angle=270+BPA+23.5, fill=False, color='r') 
	   # ax = plt.gca()
	   # x, y = np.meshgrid(ra_scale.hour, dec_scale.deg)
	   # guess = (np.max(im_list[i])/2,13.4, -9, 0.2, 0.2, 0, 0)
	   # popt, pcov = opt.curve_fit(fit_2d_gauss, (x,y), im_list[i].ravel(), p0=guess)
		ax.add_patch(p)
		ax.add_patch(b)
		#ax.add_patch(b1)
		ax.set_xlabel('RA (pix)')
		ax.set_ylabel('Declination (pix)')
		ax.set_title("Sun at "+"{:.2f}".format(self.MHz)+ " MHz "+self.obs_time)
		start_time = get_obs_start(bf_file)
		percentile_min = .1
		percentile_max = 99.9
		I_data, freq, t_arr = get_data(bf_file)
		dt = t_arr[1]-t_arr[0]
		#b_start_in = int((19276.8-t_arr[0])/dt)#t_arr.shape[0]//3 
		#b_end_in = int((19351.7-t_arr[0])/dt) #2*t_arr.shape[0]//3
		#I_data = I_data[b_start_in:b_end_in]
		datetime_start = datetime.strptime(start_time.decode("utf-8")[:-4], "%Y-%m-%dT%H:%M:%S.%f")
		timedelta_zoom_start = timedelta(seconds=t_arr[0])
		datetime_zoom_start = datetime_start + timedelta_zoom_start
		datetime_zoom_end = datetime_start + timedelta(seconds=t_arr[-1])
		xlims = list([datetime_zoom_start, datetime_zoom_end])
		xlims = dates.date2num(xlims)
		bg_sub = I_data/np.mean(I_data, axis=0)
		#bg_sub = bg_sub[b_start_in:b_end_in]
		im = ax1.imshow(bg_sub.T, aspect="auto", extent=[xlims[0], xlims[-1], freq[-1], freq[0]],
					vmax=np.percentile(bg_sub.T, percentile_max), vmin=np.percentile(bg_sub.T, percentile_min))
		ax1.xaxis_date()
		#cbar = fig.colorbar(im, ax=ax1)
		#cbar.set_label("Power", rotation=90)
		date_format = dates.DateFormatter("%H:%M:%S")
		ax1.xaxis.set_major_formatter(date_format)
		#fig.autofmt_xdate()
		ax1.axvline(x=dates.date2num(astropy.time.Time(self.obs_time).datetime), color='r')
		#ax1.axhline(y=self.MHz, color='r', linewidth=0.3)
#		ax1.set_title("Sun on "+ start_time.decode("utf-8")[:-20])#Zoom around time=" + str(round(t_arr[b_start_in])) + " to " +str(round(t_arr[b_end_in])) )
		ax1.set_xlabel("Time (UTC) ")# + start_time.decode("utf-8")[:-11] + " (s)")
		ax1.set_ylabel("Frequency (MHz)")
		plt.savefig(indir + str(self.t).zfill(4) +'.png')
		plt.close()
	#plt.show()

"""
-----------------------------
-----------------------------
Some "helpful" functions
-----------------------------
-----------------------------
"""

def coord2pix(ra, dec):
	dra = ra_scale[1]-ra_scale[0]
	ddec = dec_scale[1]-dec_scale[0]
	x = np.round((1./dra.hour)*(ra.hour-ra_scale[0].hour))
	y = np.round((1./ddec.deg)*(dec.deg-dec_scale[0].deg))
	x = int(x)
	y = int(y)
	return x, y

def pix2coord(x, y):
	ra = ra_scale[x].hour
	dec = dec_scale[y].deg
	return ra, dec

def fit_2d_gauss(xy, amp, x0, y0, sig_x, sig_y, theta, offset):
	(x, y) = xy
	x0 = float(x0)
	y0 = float(y0)
	a = ((np.cos(theta)**2)/(2*sig_x**2)) + ((np.sin(theta)**2)/(2*sig_y**2))
	b = -((np.sin(2*theta))/(4*sig_x**2)) + ((np.sin(2*theta))/(4*sig_y**2))
	c = ((np.sin(theta)**2)/(2*sig_x**2)) + ((np.cos(theta)**2)/(2*sig_y**2))
	g = amp*np.exp(-(a*((x-x0)**2) + 2*b*(x-x0)*(y-y0) + c*((y-y0)**2))) + offset
	return g.ravel()

"""
-----------------------------
-----------------------------
Plot dynamic spectra
-----------------------------
-----------------------------
"""

def get_data(f):
	SAP = f[-22:-19]
	BEAM = f[-17:-14]
	STOKES = f[-12:-11]
	with h5py.File(f, "r") as h5:
		tsamp = h5["/SUB_ARRAY_POINTING_"+ SAP + "/BEAM_"+BEAM +"/COORDINATES/COORDINATE_0"].attrs["INCREMENT"]
		freq =	h5["/SUB_ARRAY_POINTING_"+ SAP + "/BEAM_"+BEAM +"/COORDINATES/COORDINATE_1"].attrs["AXIS_VALUES_WORLD"]*1e-6
		no_samps =	h5["/SUB_ARRAY_POINTING_"+ SAP + "/BEAM_"+BEAM].attrs["NOF_SAMPLES"]

		exptime_start = astropy.time.Time(get_obs_start(f)).datetime
		#approximate guess for burst start
		burst_start = datetime(2015,10,17,13,21,16,8)
		burst_end = datetime(2015,10,17,13,22,31,7)
		burst_len = 60
		#get actual index
		burst_start_index = int(np.floor((burst_start-exptime_start).seconds/tsamp))
		burst_end_index = int(np.floor((burst_end-exptime_start).seconds/tsamp))
		#burst_end_index = burst_start_index+int(np.floor(burst_len/tsamp))

		dataset = h5["/SUB_ARRAY_POINTING_"+ SAP + "/BEAM_"+BEAM +"/STOKES_" +STOKES]
		data = dataset[burst_start_index:burst_end_index]#t[l*dataset.shape[0]//32:(l+1)*dataset.shape[0]//32]
		t_arr = tsamp*np.arange(no_samps)
		#t_arr += l*t_arr[-1]
		t_arr = t_arr[burst_start_index:burst_end_index]
	return data, freq, t_arr

def get_obs_start(f):
	SAP = f[-22:-19]
	with h5py.File(f, "r") as h5:
		group = h5["/SUB_ARRAY_POINTING_"+SAP+"/"]
		obs_start = group.attrs["EXPTIME_START_UTC"]
	return obs_start

def plot_bf(f):
	start_time = get_obs_start(f)
	percentile_min = .1
	percentile_max = 99.9
	I_data, freq, t_arr = get_data(f)
	dt = t_arr[1]-t_arr[0]
	#b_start_in = int((19276.8-t_arr[0])/dt)#t_arr.shape[0]//3 
	#b_end_in = int((19351.7-t_arr[0])/dt) #2*t_arr.shape[0]//3
	#I_data = I_data[b_start_in:b_end_in]
	datetime_start = datetime.strptime(start_time.decode("utf-8")[:-4], "%Y-%m-%dT%H:%M:%S.%f")
	timedelta_zoom_start = timedelta(seconds=t_arr[0])
	datetime_zoom_start = datetime_start + timedelta_zoom_start
	datetime_zoom_end = datetime_start + timedelta(seconds=t_arr[-1])
	xlims = list([datetime_zoom_start, datetime_zoom_end])
	xlims = dates.date2num(xlims)
	fig, ax = plt.subplots()
	bg_sub = I_data/np.mean(I_data, axis=0)
	#bg_sub = bg_sub[b_start_in:b_end_in]
	im = ax.imshow(bg_sub.T, aspect="auto", extent=[xlims[0], xlims[-1], freq[-1], freq[0]],
				vmax=np.percentile(bg_sub.T, percentile_max), vmin=np.percentile(bg_sub.T, percentile_min))
	ax.xaxis_date()
	cbar = fig.colorbar(im, ax=ax)
	cbar.set_label("Power", rotation=90)
	date_format = dates.DateFormatter("%H:%M:%S")
	ax.xaxis.set_major_formatter(date_format)
	#fig.autofmt_xdate()

	plt.title("Sun on "+ start_time.decode("utf-8")[:-20])#Zoom around time=" + str(round(t_arr[b_start_in])) + " to " +str(round(t_arr[b_end_in])) )
	plt.xlabel("Time (UTC) ")# + start_time.decode("utf-8")[:-11] + " (s)")
	plt.ylabel("Frequency (MHz)")
#	plt.tight_layout()
#	#plt.savefig("plots/"+f_name[:-3]+"_d_spec_burst_zoom2.png")
#	plt.show()
	return im, ax

def pool_class_plot(t):
	return plot_burst(t).plot_sun_pix()

"""
------------------------------
------------------------------
Plot everything in parallel
then make a movie
------------------------------
------------------------------
"""

#with Pool() as p:
#	 p.map(pool_class_plot, range(start_f, end_f))
#
#
##pdb.set_trace()
#images = glob.glob(indir+'*.png')
#images.sort()
#output = indir+'sun.mp4'
#image_path = images[0]
#frame = cv2.imread(image_path)
#cv2.imshow('video', frame)
#height, width, channels = frame.shape
#
#fourcc = cv2.VideoWriter_fourcc(*'mp4v')
#out = cv2.VideoWriter(output, fourcc, 20., (width, height))
#
#for image in images:
#	 image_path = image
#	 frame = cv2.imread(image_path)
#	 out.write(frame)
#	 cv2.imshow('video', frame)
#	 if (cv2.waitKey(1) & 0xFF) == ord('q'):
#		 break
#
#out.release()
#cv2.destroyAllWindows()


