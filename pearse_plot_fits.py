#!/usr/bin/env python
#script to view fits files generated by wsclean

import glob
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, Ellipse
from matplotlib.animation import FuncAnimation
from astropy.io import fits
import cv2
import os
import numpy as np
import sunpy.sun
import sunpy.coordinates
from sunpy.coordinates import frames
from astropy.coordinates import SkyCoord, Angle, get_sun
from astropy.table import Table, Column
import astropy.time
import sys
from matplotlib import dates
from astropy.visualization import astropy_mpl_style
from astropy import units as u
import pdb
import scipy.optimize as opt
from multiprocessing import Pool
import argparse
#assume all images are made with sam escale size etc

parser = argparse.ArgumentParser()
parser.add_argument('-indir', dest='indir', help='input directory', default='./')
parser.add_argument('-start', type=int, dest='start', help='Which file to start at (def=0)', default=0)
parser.add_argument('-end', type=int, dest='end', help='Whcih file to end at (def=-1)', default=-1)
parser.add_argument('-xpix', type=int, dest='xpix', help='How many pixels in x (def=1024)', default=1024)
parser.add_argument('-ypix', type=int, dest='ypix', help='How many pixels in y (def=1024)', default=1024)
args = parser.parse_args()
indir = args.indir


no_pix_x, no_pix_y = args.xpix, args.ypix
start_f=args.start
end_f = args.end
#pdb.set_trace()
f_list = glob.glob(indir+"*.fits")
f_list.sort()
#pdb.set_trace()

if end_f == -1:
    end_f = len(f_list)

#dec_scale = Angle(np.zeros(no_pix_y), unit='deg')
#dec_scale[513] = get_grid().dec
#dec_scale = [dec_scale[513] + (i-513)*scale for i in range(no_pix_y)]
#
#ra_scale = Angle(np.zeros(no_pix_x), unit='hourangle')
#ra_scale[513] = get_grid().ra
#ra_scale = [ra_scale[513] + (i-513)*scale for i in range(no_pix_x)]

class plot_burst:
    """
    class to define grid for correct coordinates
    and plot interferometric image
    files = list of fits files
    xpix, ypix = no of x,y pixels
    t = image index
    """
    def __init__(self,t,files=f_list,xpix=no_pix_x,ypix=no_pix_y):
        self.files = files
        self.xpix, self.ypix = xpix, ypix
        self.t = t

        with fits.open(self.files[self.t]) as hdu:
            str_start = fits.Header.tostring(hdu[0].header).find('scale')
            str_end = fits.Header.tostring(hdu[0].header).find('asec')
            self.scale = Angle(float(fits.Header.tostring(hdu[0].header)[str_start+6:str_end])*u.arcsec)
    
            self.data = hdu[0].data[0,0]
            self.obs_time = hdu[0].header['DATE-OBS']
            self.sun_pos = get_sun(astropy.time.Time(self.obs_time))#sunpy.sun.position(t=sunpy.time.parse_time(obs_time)) 
            self.BMAJ = hdu[0].header['BMAJ']
            self.BMIN = hdu[0].header['BMIN']
            self.BPA = hdu[0].header['BPA']
            self.MHz = hdu[0].header['CRVAL3']*1e-6
            self.ra_centre = int(hdu[0].header['CRPIX1']) 
            self.dec_centre = int(hdu[0].header['CRPIX2'])
    
            self.obs_ra = hdu[0].header['CRVAL1']
            self.obs_dec = hdu[0].header['CRVAL2']
    
    def get_grid(self):
       
        #obs_centre = obs_time[:11]+'12:00:00.0'
        obs_ra = Angle(self.obs_ra, unit='deg').wrap_at('360d')
        obs_dec = Angle(self.obs_dec, unit='deg')
        #RA, DEC = sunpy.sun.position(t=sunpy.time.parse_time(obs_centre))
        DIST = sunpy.coordinates.get_sunearth_distance(sunpy.time.parse_time(self.obs_time))
        grid_eq = SkyCoord(obs_ra, obs_dec, DIST, obstime=self.obs_time)
        grid_helio = grid_eq.transform_to(frames.Helioprojective)
        return grid_eq
    
    def find_sun(self):
        #find centre of sun at time t in some coordinate system
        RA, DEC = sunpy.sun.position(t=sunpy.time.parse_time(self.obs_time))
        DIST = sunpy.coordinates.get_sunearth_distance(sunpy.time.parse_time(self.obs_time)) 
        sun_eq = SkyCoord(RA, DEC, DIST, obstime=self.obs_time)
        sun_helio = sun_eq.transform_to(frames.Helioprojective)
        return sun_helio
    
    def plot_sun_pix(self):
    #plot image with sun overlaid, also include beam    
        fig,ax = plt.subplots(1,1,figsize=(6,6))
        #ax.imshow(data, origin="lower", aspect="auto", animated=True, extent=[ra_scale[0].hour, ra_scale[-1].hour, dec_scale[0].deg, dec_scale[-1].deg])
        #ax.imshow(data, origin="lower", aspect="auto", animated=True, extent=[ra_scale[0].deg, ra_scale[-1].deg, dec_scale[0].deg, dec_scale[-1].deg])
        ax.imshow(self.data, origin="lower", aspect="auto",vmax=np.percentile(self.data, 99.9), vmin=np.percentile(self.data, 0.1))
        sun_x, sun_y = self.ra_centre, self.dec_centre#coord2pix(sun_pos.ra, sun_pos.dec)
        #ax.scatter(get_grid().ra.hour, get_grid().dec.deg, c='r', marker='+')
        #ax.scatter(sun_pos.ra.deg, sun_pos.dec.deg, c='r', marker='+')
        ax.scatter(sun_x, sun_y, c='r', marker='+')
        #sun_max = np.where(data==np.max(data))
        #ax.scatter(ra_scale[sun_max[1][0]].deg, dec_scale[sun_max[0][0]].deg, c='r', marker='+') #these are reversed to what you would think
        sun_rad = Angle(0.25*u.deg)
        sun_rad_pix = sun_rad.deg/self.scale.deg
        #p = Ellipse((sun_pos.ra.deg, sun_pos.dec.deg),sun_rad.deg,sun_rad.deg, fill=False, color='r')
        p = Circle((sun_x, sun_y),sun_rad_pix, fill=False, color='r')
        #p = Ellipse((get_grid().ra.hour, get_grid().dec.deg),sun_rad.hour,sun_rad.deg, fill=False, color='r')
        #b = Ellipse((pix2coord(100,100)[0]*15, pix2coord(100,100)[1]),BMIN,BMAJ,angle=BPA+45, fill=False, color='w') 
        b = Ellipse((100,100),self.BMAJ/self.scale.deg,self.BMIN/self.scale.deg,angle=90-self.BPA+23.5, fill=False, color='w') 
        #b1 = Ellipse((513,513),BMAJ/self.scale.deg,BMIN/self.scale.deg,angle=90-BPA+23.5, fill=False, color='b') 
    #    b1 = Ellipse((pix2coord(100,100)[0]*15, pix2coord(100,100)[1]),BMAJ,BMIN,angle=270+BPA+23.5, fill=False, color='r') 
       # ax = plt.gca()
       # x, y = np.meshgrid(ra_scale.hour, dec_scale.deg)
       # guess = (np.max(im_list[i])/2,13.4, -9, 0.2, 0.2, 0, 0)
       # popt, pcov = opt.curve_fit(fit_2d_gauss, (x,y), im_list[i].ravel(), p0=guess)
        ax.add_patch(p)
        ax.add_patch(b)
        #ax.add_patch(b1)
        plt.xlabel('RA (pix)')
        plt.ylabel('Declination (pix)')
        plt.title("Sun at "+"{:.2f}".format(self.MHz)+ " MHz "+self.obs_time)
        #plt.savefig(indir + str(self.t).zfill(4) +'.png')
        #plt.close()
    #plt.show()

"""
-----------------------------
-----------------------------
Some "helpful" functions
-----------------------------
-----------------------------
"""

def coord2pix(ra, dec):
    dra = ra_scale[1]-ra_scale[0]
    ddec = dec_scale[1]-dec_scale[0]
    x = np.round((1./dra.hour)*(ra.hour-ra_scale[0].hour))
    y = np.round((1./ddec.deg)*(dec.deg-dec_scale[0].deg))
    x = int(x)
    y = int(y)
    return x, y

def pix2coord(x, y):
    ra = ra_scale[x].hour
    dec = dec_scale[y].deg
    return ra, dec

def fit_2d_gauss(xy, amp, x0, y0, sig_x, sig_y, theta, offset):
    (x, y) = xy
    x0 = float(x0)
    y0 = float(y0)
    a = ((np.cos(theta)**2)/(2*sig_x**2)) + ((np.sin(theta)**2)/(2*sig_y**2))
    b = -((np.sin(2*theta))/(4*sig_x**2)) + ((np.sin(2*theta))/(4*sig_y**2))
    c = ((np.sin(theta)**2)/(2*sig_x**2)) + ((np.cos(theta)**2)/(2*sig_y**2))
    g = amp*np.exp(-(a*((x-x0)**2) + 2*b*(x-x0)*(y-y0) + c*((y-y0)**2))) + offset
    return g.ravel()



"""
------------------------------
------------------------------
Plot everything in parallel
then make a movie
------------------------------
------------------------------
"""

#with Pool() as p:
#    p.map(plot_sun, range(start_f, end_f))


#pdb.set_trace()
#images = glob.glob(indir+'*.png')
#images.sort()
#output = indir+'sun.mp4'
#image_path = images[0]
#frame = cv2.imread(image_path)
#cv2.imshow('video', frame)
#height, width, channels = frame.shape
#
#fourcc = cv2.VideoWriter_fourcc(*'mp4v')
#out = cv2.VideoWriter(output, fourcc, 20., (width, height))
#
#for image in images:
#    image_paTH = image
#    frame = cv2.imread(image_path)
#    out.write(frame)
#    cv2.imshow('video', frame)
#    if (cv2.waitKey(1) & 0xFF) == ord('q'):
#        break
#
#out.release()
#cv2.destroyAllWindows()


